# 参考：Manus 的上下文工程原则

本技能基于 Manus 的上下文工程原则。Manus 是一家 AI 智能体公司，据报道于 2025 年 12 月被 Meta 以 20 亿美元收购。

## Manus 的六大原则

### 1. 文件系统作为外部记忆

> “Markdown 是我写在磁盘上的‘工作记忆’。”

**问题：** 上下文窗口有上限。把所有内容塞进上下文会降低效果并增加成本。

**解决：** 把文件系统当作“无限容量的记忆”：
- 大内容写进文件
- 上下文里只保留路径
- 需要时智能体可以再“查阅”文件
- 压缩必须是 **可逆的（REVERSIBLE）**

### 2. 通过重复操控注意力

**问题：** 大约 50 次工具调用后，模型会忘记原始目标（“中间丢失”效应）。

**解决：** 用一个在执行过程中会被反复阅读的 `task_plan.md`：
```
上下文开头：[原始目标——离得远、容易忘]
...很多次工具调用...
上下文末尾：[刚读过的 task_plan.md —— 更容易获得注意力！]
```

每次决策前阅读计划文件，就能把目标放回注意力窗口。

### 3. 保留失败轨迹

> “错误恢复是‘真正智能体行为（agentic behavior）’最清晰的信号之一。”

**问题：** 直觉会让人隐藏错误、静默重试。这既浪费 token，也丢掉学习机会。

**解决：** 把失败动作保留在计划文件中：
```markdown
## 遇到的错误
- [2025-01-03] FileNotFoundError：未找到 config.json → 创建默认 config
- [2025-01-03] API 超时 → 使用指数退避重试后成功
```

模型在“看到失败”时会更新内部理解，从而减少重复犯错。

### 4. 避免 Few-shot 过拟合

> “一致性会滋生脆弱性。”

**问题：** 重复的“动作-观察”对会导致漂移与幻觉。

**解决：** 引入可控的变化：
- 轻微变换措辞
- 不要盲目复制粘贴套路
- 对重复任务进行再校准

### 5. 为缓存优化设置稳定前缀

**问题：** 智能体是高输入（约 100:1）系统，每个 token 都要成本。

**解决：** 为命中缓存而结构化输入：
- 静态内容放在最前面
- 仅追加式上下文（不修改历史）
- 序列化保持一致

### 6. 仅追加式上下文

**问题：** 修改既有内容会让 KV-cache 失效。

**解决：** 永远不改历史消息，只追加新信息。

## 智能体循环

Manus 以持续循环方式运行：

```
1. 分析 → 2. 思考 → 3. 选择工具 → 4. 执行 → 5. 观察 → 6. 迭代 → 7. 交付
```

### 循环中的文件操作

| 操作 | 何时使用 |
|------|----------|
| `write` | 新建文件或整体重写 |
| `append` | 逐步追加新段落 |
| `edit` | 更新局部内容（复选框、状态等） |
| `read` | 决策前复查 |

## Manus 关键数据

| 指标 | 数值 |
|------|------|
| 单任务平均工具调用次数 | ~50 |
| 输入输出比 | 100:1 |
| 收购价格 | 20 亿美元 |
| 达到 1 亿美元收入所用时间 | 8 个月 |

## 关键引述

> “如果模型进步是上涨的潮水，我们希望 Manus 是船，而不是卡在海床上的桩。”

> “面对复杂任务，我会把笔记、代码和发现保存到文件里，便于在工作过程中随时回查。”

> “我会在推进过程中用 file.edit 更新计划里的复选框，而不是重写整个文件。”

## 来源

基于 Manus 的官方上下文工程文档：
https://manus.im/de/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus
